package com.wipro.training.bank.service;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;

import org.springframework.stereotype.Service;

import com.wipro.training.bank.dao.AccountDetailsDTO;
import com.wipro.training.bank.dao.LoginRequest;
import com.wipro.training.bank.dao.RegisterRequest;
import com.wipro.training.bank.dao.ResetPasswordRequest;
import com.wipro.training.bank.exception.ResourceNotFoundException;
import com.wipro.training.bank.model.Account;
import com.wipro.training.bank.model.Payee;
import com.wipro.training.bank.model.Transaction;
import com.wipro.training.bank.repository.AccountRepository;
import com.wipro.training.bank.util.EncryptionUtil;

/*
Author-Abhinav Kumar
Date-Sep 13, 2024
Time-9:36:10â€¯AM
Project-daily-bank
 */

@Service
public class AccountService {

	private final AccountRepository accountRepository;

	//DI using constructor
	public AccountService(AccountRepository accountRepository) {
		this.accountRepository = accountRepository;
	}

	public Account openAccount(Account account) {
		// Generate a 10-digit unique account number
		account.setAccountNumber(generateAccountNumber());
		return accountRepository.save(account);
	}

	public Account registerInternetBanking(RegisterRequest request) {
		Account account = accountRepository.findByAccountNumber(request.getAccountNumber());
		if (account != null) {
			if (request.getLoginPassword().equals(request.getConfirmLoginPassword()) &&
					request.getTransactionPassword().equals(request.getConfirmTransactionPassword())) {

				// Encrypt passwords before saving
				account.setUserId(request.getUserId());
				account.setLoginPassword(EncryptionUtil.encrypt(request.getLoginPassword()));
				account.setTransactionPassword(EncryptionUtil.encrypt(request.getTransactionPassword()));

				return accountRepository.save(account);
			} else {
				throw new IllegalArgumentException("Passwords do not match");
			}
		}
		return null;
	}

	public Account login(LoginRequest loginRequest) {
		Account account = accountRepository.findByUserId(loginRequest.getUserId());
		if (account != null) {
			// Decrypt the stored password and compare with the provided password
			String decryptedPassword = EncryptionUtil.decrypt(account.getLoginPassword());
			if (decryptedPassword.equals(loginRequest.getLoginPassword())) {
				return account; // Login successful
			} else {
				throw new IllegalArgumentException("Invalid login credentials");
			}
		} else {
			throw new IllegalArgumentException("Account not found");
		}
	}

	public AccountDetailsDTO getAccountDetails(String accountNumber) {
		Account account = accountRepository.findByAccountNumber(accountNumber);
		if (account != null) {
			AccountDetailsDTO dto = new AccountDetailsDTO();
			dto.setAccountNumber(account.getAccountNumber());
			dto.setUserId(account.getUserId());
			dto.setTitle(account.getPersonalDetails().getTitle());
			dto.setFirstName(account.getPersonalDetails().getFirstName());
			dto.setMiddleName(account.getPersonalDetails().getMiddleName());
			dto.setLastName(account.getPersonalDetails().getLastName());
			dto.setFatherName(account.getPersonalDetails().getFatherName());
			dto.setEmail(account.getPersonalDetails().getEmail());
			dto.setMobile(account.getPersonalDetails().getMobile());
			dto.setAdhar(account.getPersonalDetails().getAdhar());
			dto.setDob(account.getPersonalDetails().getDob());
			dto.setAddressLine1(account.getAddress().getAddressLine1());
			dto.setAddressLine2(account.getAddress().getAddressLine2());
			dto.setLandmark(account.getAddress().getLandmark());
			dto.setCity(account.getAddress().getCity());
			dto.setState(account.getAddress().getState());
			dto.setPincode(account.getAddress().getPincode());

			return dto;
		} else {
			return null;
		}
	}

	private String generateAccountNumber() {
		// Logic to generate unique 10-digit account number
		return String.valueOf((long)(Math.random() * 1_000_000_000L + 1_000_000_000L));
	}
	public List<Transaction> getTransactionDetails(String accountNumber) {
		Account account = accountRepository.findByAccountNumber(accountNumber);
		if (account != null && account.getAdmin() != null) {
			return account.getAdmin().getTransactions();
		} else {
			throw new IllegalArgumentException("Account or transaction details not found");
		}
	}

	

	public Account addPayee(String accountNumber, Payee newPayee, String confirmAccountNumber) {
		// Check if the account to which we are adding the payee exists
		Account account = accountRepository.findByAccountNumber(accountNumber);
		if (account == null) {
			throw new ResourceNotFoundException("Account with account number " + accountNumber + " not found.");
		}

		// Check if the account numbers match
		if (!newPayee.getAccountNumber().equals(confirmAccountNumber)) {
			throw new ResourceNotFoundException("Account number and confirmation account number do not match.");
		}

		// Verify that the payee's account number exists in the database
		Account payeeAccount = accountRepository.findByAccountNumber(newPayee.getAccountNumber());
		if (payeeAccount == null) {
			throw new ResourceNotFoundException("Payee's account number " + newPayee.getAccountNumber() + " not found.");
		}

		// Check if the payee already exists for this account
		boolean payeeExists = account.getPayees().stream()
				.anyMatch(existingPayee -> existingPayee.getAccountNumber().equals(newPayee.getAccountNumber()));

		if (payeeExists) {
			throw new IllegalArgumentException("Payee with account number " + newPayee.getAccountNumber() + " already exists in the account.");
		}

		// Add the new payee to the account's payee list
		account.getPayees().add(newPayee);
		return accountRepository.save(account);
	}

	public Account performNEFTTransaction(String fromAccountNumber, String toAccountNumber, double amount, String remark) {
		// Find both accounts
		Account fromAccount = accountRepository.findByAccountNumber(fromAccountNumber);
		Account toAccount = accountRepository.findByAccountNumber(toAccountNumber);

		if (fromAccount == null || toAccount == null) {
			throw new ResourceNotFoundException("One or both accounts not found");
		}

		// Check if sender has sufficient balance
		double currentBalance = fromAccount.getAdmin().getTotalAmount();
		if (currentBalance < amount) {
			throw new IllegalArgumentException("Insufficient funds in the account");
		}

		// Debit transaction for sender's account
		Transaction debitTransaction = new Transaction();
		debitTransaction.setFromAccount(fromAccountNumber);
		debitTransaction.setToAccount(toAccountNumber);
		debitTransaction.setAmount(amount);
		debitTransaction.setType("NEFT DEBIT");
		debitTransaction.setTotalAmount(currentBalance - amount);
		debitTransaction.setTransactionDate(LocalDateTime.now());
		debitTransaction.setRemark(remark);

		// Update sender's balance and save transaction
		fromAccount.getAdmin().setTotalAmount(currentBalance - amount);
		fromAccount.getAdmin().getTransactions().add(debitTransaction);
		accountRepository.save(fromAccount);

		// Credit transaction for recipient's account
		Transaction creditTransaction = new Transaction();
		creditTransaction.setFromAccount(fromAccountNumber);
		creditTransaction.setToAccount(toAccountNumber);
		creditTransaction.setAmount(amount);
		creditTransaction.setType("NEFT CREDIT");
		creditTransaction.setTotalAmount(toAccount.getAdmin().getTotalAmount() + amount);
		creditTransaction.setTransactionDate(LocalDateTime.now());
		creditTransaction.setRemark(remark);

		// Update recipient's balance and save transaction
		toAccount.getAdmin().setTotalAmount(toAccount.getAdmin().getTotalAmount() + amount);
		toAccount.getAdmin().getTransactions().add(creditTransaction);
		accountRepository.save(toAccount);

		return fromAccount;  // Returning the updated sender's account
	}

	public List<Payee> getPayees(String accountNumber) {
		Account account = accountRepository.findByAccountNumber(accountNumber);
		if (account != null) {
			return account.getPayees();
		} else {
			throw new IllegalArgumentException("Account with account number " + accountNumber + " not found.");
		}
	}

	public String generateOtp(String userId) {
		// Generate a 6-digit OTP
		String otp = String.format("%06d", random.nextInt(1000000));
		otpStorage.put(userId, otp); // Store OTP temporarily
		return otp;
	}

	public boolean verifyOtp(String userId, String otp) {
		String storedOtp = otpStorage.get(userId);
		return storedOtp != null && storedOtp.equals(otp);
	}

	public void resetPassword(ResetPasswordRequest request) {
		if (verifyOtp(request.getUserId(), request.getOtp())) {
			Account account = accountRepository.findByUserId(request.getUserId());
			if (account != null) {
				account.setLoginPassword(EncryptionUtil.encrypt(request.getNewPassword()));
				accountRepository.save(account);
			} else {
				throw new IllegalArgumentException("User not found");
			}
		} else {
			throw new IllegalArgumentException("Invalid OTP");
		}
	}

	public Account setNewPassword(String userId, String oldPassword, String newPassword, String confirmNewPassword) {
	    Account account = accountRepository.findByUserId(userId);
	    if (account == null) {
	        throw new ResourceNotFoundException("User not found");
	    }

	    // Decrypt the current password and check if it matches the provided old password
	    String decryptedOldPassword = EncryptionUtil.decrypt(account.getLoginPassword());
	    if (!decryptedOldPassword.equals(oldPassword)) {
	        throw new IllegalArgumentException("Old password is incorrect");
	    }

	    // Check if new password and confirmation match
	    if (!newPassword.equals(confirmNewPassword)) {
	        throw new IllegalArgumentException("New password and confirmation password do not match");
	    }

	    // Encrypt the new password and save it
	    account.setLoginPassword(EncryptionUtil.encrypt(newPassword));
	    return accountRepository.save(account);
	}
	
	public Transaction getRecentTransaction(String accountNumber) {
	    Account account = accountRepository.findByAccountNumber(accountNumber);
	    if (account != null) {
	        List<Transaction> transactions = account.getAdmin().getTransactions();
	        if (transactions != null && !transactions.isEmpty()) {
	            // Sort transactions by date in descending order and return the most recent one
	            transactions.sort((t1, t2) -> t2.getTransactionDate().compareTo(t1.getTransactionDate()));
	            return transactions.get(0); // Return the most recent transaction
	        } else {
	            throw new ResourceNotFoundException("No transactions found for account number " + accountNumber);
	        }
	    } else {
	        throw new ResourceNotFoundException("Account with account number " + accountNumber + " not found.");
	    }
	}
	
	private final Map<String, String> otpStorage = new HashMap<>(); // Temporary in-memory OTP storage
	private final Random random = new Random();
	

}
